#include <Windows.h>
#include <iostream>
#include <NuiApi.h>
#include <opencv2/opencv.hpp>

using namespace std;
using namespace cv;


int main(int argc, char* argv[])
{
    cv::Mat skeletonImg;
    skeletonImg.create(240, 320, CV_8UC3);
    cv::Point skeletonPoint[NUI_SKELETON_COUNT][NUI_SKELETON_POSITION_COUNT] = { cv::Point(0, 0) };
    bool tracked[NUI_SKELETON_COUNT];

    // 1、Initialize the NUI
    HRESULT hr = NuiInitialize(NUI_INITIALIZE_FLAG_USES_SKELETON);
    if (FAILED(hr))
    {
        cout << "NuiInitialize failed" << endl;
        return hr;
    }

    // 2、Defines the skeleton signal event handle
    HANDLE skeletonEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    // 3、Open skeleton data trace events
    hr = NuiSkeletonTrackingEnable(skeletonEvent, 0);
    if (FAILED(hr))
    {
        cout << "Could not open skeleton tracking event" << endl;
        NuiShutdown();
        return hr;
    }
    cv::namedWindow("skeletonImg", CV_WINDOW_AUTOSIZE);

    // 4、Start reading skeleton data
    while (1)
    {
        NUI_SKELETON_FRAME skeletonFrame = { 0 };   //Definition of skeleton frames
        bool foundSkeleton = false;

        // 4.1、It waits indefinitely for new data and returns when it is received
        if (WaitForSingleObject(skeletonEvent, INFINITE) == 0)
        {
            // 4.2、A skeleton data frame is read and the address is stored in the skeletonFrame
            hr = NuiSkeletonGetNextFrame(0, &skeletonFrame);
            if (SUCCEEDED(hr))
            {
              
                for (int i = 0; i < NUI_SKELETON_COUNT; i++)
                {
                    NUI_SKELETON_TRACKING_STATE trackingState = skeletonFrame.SkeletonData[i].eTrackingState;

                 
                    if (trackingState == NUI_SKELETON_TRACKED)
                    {
                        foundSkeleton = true;
                    }
                }
            }

            if (!foundSkeleton)
            {
                continue;
            }
            NuiTransformSmooth(&skeletonFrame, NULL);
            skeletonImg.setTo(0);

            for (int i = 0; i < NUI_SKELETON_COUNT; i++)
            {
                // A condition to determine if the bone is correct: the bone is tracked to and must be tracked to the center of the shoulder (neck position)
                if (skeletonFrame.SkeletonData[i].eTrackingState == NUI_SKELETON_TRACKED && skeletonFrame.SkeletonData[i].eSkeletonPositionTrackingState[NUI_SKELETON_POSITION_SHOULDER_CENTER] != NUI_SKELETON_POSITION_NOT_TRACKED)
                {
                    float fx, fy;
                // Take the coordinates of all tracked nodes and convert them to the coordinates of our depth space, because we are in the depth image
                // Mark up the nodes
                // NUI_SKELETON_POSITION_COUNT is the number of nodes tracked to a skeleton, which is 20
                    for (int j = 0; j < NUI_SKELETON_POSITION_COUNT; j++)
                    {
                        NuiTransformSkeletonToDepthImage(skeletonFrame.SkeletonData[i].SkeletonPositions[j], &fx, &fy);
                        skeletonPoint[i][j].x = (int)fx;
                        skeletonPoint[i][j].y = (int)fy;
                    }

                    for (int j = 0; j < NUI_SKELETON_POSITION_COUNT; j++)
                    {
                        if (skeletonFrame.SkeletonData[i].eSkeletonPositionTrackingState[j] != NUI_SKELETON_POSITION_NOT_TRACKED)
                        {
                            cv::circle(skeletonImg, skeletonPoint[i][j], 3, cv::Scalar(0, 255, 255), 1, 8, 0);
                            tracked[i] = true;
                        }
                    }

                    drawSkeleton(skeletonImg, skeletonPoint[i], i);
                }
            }
            imshow("skeletonImg", skeletonImg);
        }
        else
        {
            cout << "Buffer length of received texture is bogus\r\n" << endl;
        }

        if (cv::waitKey(20) == 27)
            break;
    }
    //5、Close the NUI link
    NuiShutdown();
    cv::destroyAllWindows();

    return 0;
}

//typedef struct _NUI_SKELETON_DATA {

 // NUI_SKELETON_TRACKING_STATE eTrackingState;

 //  DWORD dwTrackingID;

//   DWORD dwEnrollmentIndex;

 //   DWORDdwUserIndex;

 //  Vector4 Position;

 //  Vector4 SkeletonPositions[20];

//   NUI_SKELETON_POSITION_TRACKING_STATE eSkeletonPositionTrackingState[20];

 //  DWORD dwQualityFlags;

// } NUI_SKELETON_DATA;


//Vector4typedef struct _Vector4 {

//   FLOAT x;  //X coordinate

//   FLOAT y;  //Y coordinate

//   FLOAT z;  //Z coordinate

//   FLOAT w;  //W coordinate

// } Vector4;

